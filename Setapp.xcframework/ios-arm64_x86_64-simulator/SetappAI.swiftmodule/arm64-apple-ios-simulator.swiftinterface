// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.3 (swiftlang-6.2.3.3.21 clang-1700.6.3.2)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -enable-upcoming-feature ExistentialAny:migrate -enable-upcoming-feature MemberImportVisibility:migrate -enable-upcoming-feature NonisolatedNonsendingByDefault:migrate -enable-experimental-feature DebugDescriptionMacro -module-name SetappAI -package-name setappai
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.3
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct AIConfiguration : Swift.Sendable {
  public let authConfiguration: SetappAI.AuthConfiguration
  public let mode: SetappAI.ErrorHandlingMode
  public init(authConfiguration: SetappAI.AuthConfiguration, mode: SetappAI.ErrorHandlingMode = .autoPresent)
}
public protocol AuthorizationCodeProviderProtocol : Swift.Sendable {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func fetchAuthorizationCode(clientID: Swift.String, scope: [Swift.String]) async throws -> Swift.String
  #endif
}
public struct AuthConfiguration : Swift.Sendable {
  public let oauthClientId: Swift.String
  public let oauthSecret: Swift.String
  public init(oauthClientId: Swift.String, oauthSecret: Swift.String)
}
public enum ErrorHandlingMode : Swift.Sendable {
  case autoPresent
  case propagate
  public static func == (a: SetappAI.ErrorHandlingMode, b: SetappAI.ErrorHandlingMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SetappAIErrorConvertible : Swift.Error {
  func asSetappAIError() throws -> SetappAI.SetappAIError
}
public struct SetappAIError : Swift.Error {
  public let code: SetappAI.SetappAIError.ErrorCode
  public let recoveryURL: Foundation.URL?
  public init(code: SetappAI.SetappAIError.ErrorCode)
  #if compiler(>=5.3) && $NonescapableTypes
  public init(code: SetappAI.SetappAIError.ErrorCode, underlyingError: (any Swift.Error)?, recoveryURL: Foundation.URL?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func updateLocalizedStrings(description: Swift.String? = nil, failureReason: Swift.String? = nil, recoverySuggestion: Swift.String? = nil, recoveryOption: Swift.String? = nil, closeOption: Swift.String? = nil)
  #endif
}
extension SetappAI.SetappAIError : Swift.Equatable {
  public static func == (lhs: SetappAI.SetappAIError, rhs: SetappAI.SetappAIError) -> Swift.Bool
}
extension SetappAI.SetappAIError {
  public enum ErrorCode : Swift.Int, Swift.Equatable, Swift.Sendable {
    case general
    case rateLimit
    case insufficientCredits
    case modelNotAllowed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var failureReason: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var recoverySuggestion: Swift.String? {
    get
  }
  #endif
}
extension SetappAI.SetappAIError : Foundation.CustomNSError {
  public static let errorDomain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Swift.Dictionary {
  @inlinable @inline(__always) package func mergingTheirs(_ other: Swift.Dictionary<Key, Value>) -> Swift.Dictionary<Key, Value> {
        merging(other, uniquingKeysWith: { _, new in new })
    }
}
extension Swift.KeyedDecodingContainer {
  @inlinable @inline(__always) package func decode<T>(_ key: Swift.KeyedDecodingContainer<K>.Key) throws -> T where T : Swift.Decodable {
        try decode(T.self, forKey: key)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable @inline(__always) package func decodeIfPresent<T>(_ key: Swift.KeyedDecodingContainer<K>.Key) throws -> T? where T : Swift.Decodable {
        try decodeIfPresent(T.self, forKey: key)
    }
  #endif
}
public protocol SetappAIRawStringRepresentableEnum : SetappAI.SetappAIRawStringRepresentable, Swift.CaseIterable where Self.RawValue : Swift.Equatable {
  static func unsupported(_ rawValue: Self.RawValue) -> Self
}
extension SetappAI.SetappAIRawStringRepresentableEnum {
  public init(rawValue: Self.RawValue)
}
public protocol SetappAIRawStringRepresentable : Swift.Decodable, Swift.Encodable, Swift.ExpressibleByStringLiteral, Swift.Hashable, Swift.RawRepresentable, Swift.Sendable where Self.RawValue == Self.StringLiteralType {
  init(rawValue: Self.RawValue)
}
extension SetappAI.SetappAIRawStringRepresentable where Self.RawValue : Swift.ExpressibleByStringLiteral {
  @inlinable @inline(__always) public init(stringLiteral value: Self.StringLiteralType) {
        self.init(rawValue: value)
    }
}
extension SetappAI.SetappAIRawStringRepresentable where Self.RawValue : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIRawStringRepresentable where Self.RawValue : Swift.Encodable {
  @inlinable @inline(__always) public func encode(to encoder: any Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
}
extension SetappAI.SetappAIRawStringRepresentable where Self.RawValue : Swift.Equatable {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public static func == (lhs: Self.RawValue, rhs: Self) -> Swift.Bool
  public static func == (lhs: Self, rhs: Self.RawValue) -> Swift.Bool
}
extension SetappAI.SetappAIRawStringRepresentable where Self.RawValue : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
extension SetappAI.SetappAIAPI.Model {
  public struct Capability : SetappAI.SetappAIRawStringRepresentable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
extension SetappAI.SetappAIAPI.Model.Capability {
  public static let systemMessages: SetappAI.SetappAIAPI.Model.Capability
  public static let responseSchema: SetappAI.SetappAIAPI.Model.Capability
  public static let vision: SetappAI.SetappAIAPI.Model.Capability
  public static let functionCalling: SetappAI.SetappAIAPI.Model.Capability
  public static let toolChoice: SetappAI.SetappAIAPI.Model.Capability
  public static let promptCaching: SetappAI.SetappAIAPI.Model.Capability
  public static let pdfInput: SetappAI.SetappAIAPI.Model.Capability
  public static let nativeStreaming: SetappAI.SetappAIAPI.Model.Capability
  public static let reasoning: SetappAI.SetappAIAPI.Model.Capability
}
extension Swift.Set where Element == SetappAI.SetappAIAPI.Model.Capability {
  @inlinable @inline(__always) public func supports(_ capability: Element) -> Swift.Bool { contains(capability) }
}
extension SetappAI.SetappAIAPI.Model {
  public struct Mode : SetappAI.SetappAIRawStringRepresentable {
    public typealias RawValue = Swift.String
    public let rawValue: SetappAI.SetappAIAPI.Model.Mode.RawValue
    public init(rawValue: SetappAI.SetappAIAPI.Model.Mode.RawValue)
    public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Model.Mode.RawValue
    public typealias StringLiteralType = SetappAI.SetappAIAPI.Model.Mode.RawValue
    public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Model.Mode.RawValue
  }
}
extension SetappAI.SetappAIAPI.Model.Mode {
  public static let audioSpeech: SetappAI.SetappAIAPI.Model.Mode
  public static let audioTranscription: SetappAI.SetappAIAPI.Model.Mode
  public static let chat: SetappAI.SetappAIAPI.Model.Mode
  public static let completion: SetappAI.SetappAIAPI.Model.Mode
  public static let embedding: SetappAI.SetappAIAPI.Model.Mode
  public static let imageGeneration: SetappAI.SetappAIAPI.Model.Mode
  public static let moderation: SetappAI.SetappAIAPI.Model.Mode
  public static let rerank: SetappAI.SetappAIAPI.Model.Mode
  public static let search: SetappAI.SetappAIAPI.Model.Mode
}
extension SetappAI.SetappAIAPI {
  public struct Model : Swift.Sendable, Swift.Equatable, Swift.Identifiable {
    public var id: Swift.String
    public var mode: SetappAI.SetappAIAPI.Model.Mode?
    public var capabilities: Swift.Set<SetappAI.SetappAIAPI.Model.Capability>
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, mode: SetappAI.SetappAIAPI.Model.Mode?, capabilities: Swift.Set<SetappAI.SetappAIAPI.Model.Capability>)
    #endif
    public static func == (a: SetappAI.SetappAIAPI.Model, b: SetappAI.SetappAIAPI.Model) -> Swift.Bool
    public typealias ID = Swift.String
  }
}
extension SetappAI.SetappAIAPI.Model : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Model.StringLiteralType
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Model.StringLiteralType
}
public protocol SetappAIModelsAPIProtocol : Swift.Sendable {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func list() async throws -> [SetappAI.SetappAIAPI.Model]
  #endif
}
extension SetappAI.SetappAIAPI {
  public struct Models : Swift.Sendable {
  }
}
extension SetappAI.SetappAIAPI.Models : SetappAI.SetappAIModelsAPIProtocol {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func list() async throws -> [SetappAI.SetappAIAPI.Model]
  #endif
}
extension SetappAI.SetappAIAPI.Responses {
  public struct CreateRequestParameters : Swift.Sendable {
    public var model: SetappAI.SetappAIAPI.Model
    public var input: [any SetappAI.ModelInputProtocol]
    public var instructions: Swift.String?
    public var contextManagement: SetappAI.SetappAIAPI.Responses.ContextManagement?
    public var reasoning: SetappAI.SetappAIAPI.Responses.Reasoning?
    public var previousResponseID: Swift.String?
    public var text: SetappAI.SetappAIAPI.Responses.Text?
    public var include: [SetappAI.SetappAIAPI.Responses.Include]?
    public var tools: [any SetappAI.SetappAIResponsesToolProtocol]?
    public var toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice?
    public var maxToolCalls: Swift.Int?
    public var parallelToolCalls: Swift.Bool?
    public var serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier?
    public var store: Swift.Bool?
    public var truncation: SetappAI.SetappAIAPI.Responses.Truncation?
    public var metadata: [Swift.String : Swift.String]?
    public var maxOutputTokens: Swift.Int?
    public var temperature: Swift.Double?
    public var topP: Swift.Double?
    public var topLogprobs: Swift.Int?
    public var background: Swift.Bool?
    public var stream: Swift.Bool?
    public var streamOptions: SetappAI.SetappAIAPI.Responses.StreamOptions?
  }
}
extension SetappAI.SetappAIAPI.Responses.CreateRequestParameters {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(model: SetappAI.SetappAIAPI.Model, input: [any SetappAI.ModelInputProtocol], instructions: Swift.String? = nil, contextManagement: SetappAI.SetappAIAPI.Responses.ContextManagement? = nil, reasoning: SetappAI.SetappAIAPI.Responses.Reasoning? = nil, previousResponseID: Swift.String? = nil, text: SetappAI.SetappAIAPI.Responses.Text? = nil, include: [SetappAI.SetappAIAPI.Responses.Include]? = nil, tools: [any SetappAI.SetappAIResponsesToolProtocol]? = nil, toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice? = nil, maxToolCalls: Swift.Int? = nil, parallelToolCalls: Swift.Bool? = nil, serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier? = nil, store: Swift.Bool? = nil, truncation: SetappAI.SetappAIAPI.Responses.Truncation? = nil, metadata: [Swift.String : Swift.String]? = nil, maxOutputTokens: Swift.Int? = nil, temperature: Swift.Double? = nil, topP: Swift.Double? = nil, topLogprobs: Swift.Int? = nil, background: Swift.Bool? = nil, stream: Swift.Bool? = nil, streamOptions: SetappAI.SetappAIAPI.Responses.StreamOptions? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(model: SetappAI.SetappAIAPI.Model, input: [SetappAI.SetappAIAPI.Responses.Input], instructions: Swift.String? = nil, contextManagement: SetappAI.SetappAIAPI.Responses.ContextManagement? = nil, reasoning: SetappAI.SetappAIAPI.Responses.Reasoning? = nil, previousResponseID: Swift.String? = nil, text: SetappAI.SetappAIAPI.Responses.Text? = nil, include: [SetappAI.SetappAIAPI.Responses.Include]? = nil, tools: [SetappAI.SetappAIAPI.Responses.Tool]? = nil, toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice? = nil, maxToolCalls: Swift.Int? = nil, parallelToolCalls: Swift.Bool? = nil, serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier? = nil, store: Swift.Bool? = nil, truncation: SetappAI.SetappAIAPI.Responses.Truncation? = nil, metadata: [Swift.String : Swift.String]? = nil, maxOutputTokens: Swift.Int? = nil, temperature: Swift.Double? = nil, topP: Swift.Double? = nil, topLogprobs: Swift.Int? = nil, background: Swift.Bool? = nil, stream: Swift.Bool? = nil, streamOptions: SetappAI.SetappAIAPI.Responses.StreamOptions? = nil)
  #endif
}
extension SetappAI.SetappAIAPI.Responses.CreateRequestParameters : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.CreateRequestParameters : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public struct GetResponseParameters : Swift.Sendable {
    public var include: [SetappAI.SetappAIAPI.Responses.Include]?
    public var includeObfuscation: Swift.Bool?
    public var startingAfter: Swift.Int?
    public var stream: Swift.Bool?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(include: [SetappAI.SetappAIAPI.Responses.Include]? = nil, includeObfuscation: Swift.Bool? = nil, startingAfter: Swift.Int? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Input {
  public struct ItemReference : Swift.Sendable, Swift.Equatable {
    public let id: Swift.String
    public init(id: Swift.String)
    public static func == (a: SetappAI.SetappAIAPI.Responses.Input.ItemReference, b: SetappAI.SetappAIAPI.Responses.Input.ItemReference) -> Swift.Bool
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.ItemReference : SetappAI.ModelInputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.InputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.ItemReference : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.ItemReference : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input {
  public struct MCPApprovalResponse : Swift.Sendable {
    public var approvalRequestID: Swift.String
    public var approve: Swift.Bool
    public var id: Swift.String?
    public var reason: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(approvalRequestID: Swift.String, approve: Swift.Bool, id: Swift.String? = .none, reason: Swift.String? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.MCPApprovalResponse : SetappAI.ModelInputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.InputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.MCPApprovalResponse : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.MCPApprovalResponse : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ModelInputMessageContentProtocol : Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType { get }
}
extension SetappAI.SetappAIAPI.Responses.Input {
  public struct Message {
    public var id: Swift.String?
    public let content: [SetappAI.SetappAIAPI.Responses.Input.Message.Content]
    public var role: SetappAI.SetappAIAPI.Responses.Role
    public var status: SetappAI.SetappAIAPI.Responses.Input.Message.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(content: [SetappAI.SetappAIAPI.Responses.Input.Message.Content], role: SetappAI.SetappAIAPI.Responses.Role = .user, id: Swift.String? = .none, status: SetappAI.SetappAIAPI.Responses.Input.Message.Status? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message : SetappAI.ModelInputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.InputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message {
  public enum Status : Swift.Sendable {
    public typealias RawValue = Swift.String
    case inProgress
    case completed
    case incomplete
    case unsupported(SetappAI.SetappAIAPI.Responses.Input.Message.Status.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Status : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Input.Message.Status]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Input.Message.Status]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Status.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Status.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Status.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Input.Message {
  public enum Content : Swift.Sendable {
    case text(SetappAI.SetappAIAPI.Responses.Input.Message.Text)
    case image(SetappAI.SetappAIAPI.Responses.Input.Message.Image)
    case file(SetappAI.SetappAIAPI.Responses.Input.Message.File)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType>)
  }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.ModelInputMessageContentProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType {
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content {
  public static func text(_ text: Swift.String) -> SetappAI.SetappAIAPI.Responses.Input.Message.Content
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content : SetappAI.ModelInputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType {
    get
  }
  @inlinable @inline(__always) internal var object: any SetappAI.ModelInputMessageContentProtocol {
    get {
        switch self {
        case let .text(text): text
        case let .image(image): image
        case let .file(file): file
        case let .unsupported(unsupported): unsupported
        }
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content {
  public enum ContentType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case text
    case image
    case file
    case unsupported(SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Content : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message {
  public struct File : Swift.Sendable, Swift.Equatable {
    public let fileData: Foundation.Data?
    public let fileID: Swift.String?
    public let fileURL: Foundation.URL?
    public let filename: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fileData: Foundation.Data?, fileID: Swift.String?, fileURL: Foundation.URL?, filename: Swift.String?)
    #endif
    public static func == (a: SetappAI.SetappAIAPI.Responses.Input.Message.File, b: SetappAI.SetappAIAPI.Responses.Input.Message.File) -> Swift.Bool
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.File {
  public static func data(_ data: Foundation.Data, filename: Swift.String) -> SetappAI.SetappAIAPI.Responses.Input.Message.File
  public static func fileURL(_ fileURL: Foundation.URL, filename: Swift.String) -> SetappAI.SetappAIAPI.Responses.Input.Message.File
  public static func fileID(_ fileID: Swift.String) -> SetappAI.SetappAIAPI.Responses.Input.Message.File
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.File : SetappAI.ModelInputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.File : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.File : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message {
  public struct Image : Swift.Sendable, Swift.Equatable {
    public let detail: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail?
    public let imageType: SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType?
    public let data: Foundation.Data?
    public let imageURL: Foundation.URL?
    public let fileID: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(detail: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail?, imageType: SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType?, fileID: Swift.String?, imageURL: Foundation.URL?, data: Foundation.Data?)
    #endif
    public static func == (a: SetappAI.SetappAIAPI.Responses.Input.Message.Image, b: SetappAI.SetappAIAPI.Responses.Input.Message.Image) -> Swift.Bool
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image : SetappAI.ModelInputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func data(_ data: Foundation.Data, type: SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType, detail: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail? = .none) -> SetappAI.SetappAIAPI.Responses.Input.Message.Image
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func imageURL(_ imageURL: Foundation.URL, detail: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail? = .none) -> SetappAI.SetappAIAPI.Responses.Input.Message.Image
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fileID(_ fileID: Swift.String, detail: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail? = .none) -> SetappAI.SetappAIAPI.Responses.Input.Message.Image
  #endif
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image {
  public enum Detail : Swift.Sendable {
    public typealias RawValue = Swift.String
    case high
    case low
    case auto
    case unsupported(SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.Detail.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image {
  public enum ImageType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case jpeg
    case png
    case webp
    case gif
    case unsupported(SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Image : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message {
  public struct Text : Swift.Sendable, Swift.Equatable {
    public let text: Swift.String
    public init(_ text: Swift.String)
    public static func == (a: SetappAI.SetappAIAPI.Responses.Input.Message.Text, b: SetappAI.SetappAIAPI.Responses.Input.Message.Text) -> Swift.Bool
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Text : SetappAI.ModelInputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.Message.Content.ContentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Text : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input.Message.Text : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ModelInputProtocol : Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Input.InputType { get }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.ModelInputProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Input.InputType {
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Input {
    case message(SetappAI.SetappAIAPI.Responses.Input.Message)
    case itemReference(SetappAI.SetappAIAPI.Responses.Input.ItemReference)
    case output(SetappAI.SetappAIAPI.Responses.Output)
    case mcpApprovalResponse(SetappAI.SetappAIAPI.Responses.Input.MCPApprovalResponse)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Input.InputType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input {
  public static func message(_ text: Swift.String) -> SetappAI.SetappAIAPI.Responses.Input
}
extension SetappAI.SetappAIAPI.Responses.Input : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SetappAI.SetappAIAPI.Responses.Input : SetappAI.ModelInputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Input.InputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Input {
  public enum InputType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case message
    case itemReference
    case output(SetappAI.SetappAIAPI.Responses.Output.OutputType)
    case mcpApprovalResponse
    case unsupported(SetappAI.SetappAIAPI.Responses.Input.InputType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Input.InputType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Input.InputType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Input.InputType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Input.InputType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Input.InputType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Input.InputType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Input.InputType.RawValue
}
extension SetappAI.SetappAIAPI.Responses {
  public struct ContextManagement : Swift.Sendable {
    public var compactThreshold: Swift.Int?
    public var type: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(compactThreshold: Swift.Int? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.ContextManagement : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ContextManagement : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Error : Swift.Sendable {
    public let code: Swift.String
    public let message: Swift.String
  }
}
extension SetappAI.SetappAIAPI.Responses.Error : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Include : SetappAI.SetappAIRawStringRepresentable {
    public typealias RawValue = Swift.String
    public let rawValue: SetappAI.SetappAIAPI.Responses.Include.RawValue
    public init(rawValue: SetappAI.SetappAIAPI.Responses.Include.RawValue)
    public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Include.RawValue
    public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Include.RawValue
    public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Include.RawValue
  }
}
extension SetappAI.SetappAIAPI.Responses.Include {
  public static var webSearchCallSources: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var codeInterpreterCallOutputs: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var computerCallOutputs: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var fileSearchCallResults: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var messageInputImageURLs: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var messageOutputTextLogprobs: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var reasoningEncryptedContent: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
  public static var webSearchCallResults: SetappAI.SetappAIAPI.Responses.Include {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public struct IncompleteDetails : Swift.Sendable {
    public let reason: Swift.String?
  }
}
extension SetappAI.SetappAIAPI.Responses.IncompleteDetails : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Instructions : Swift.Sendable {
    case string(Swift.String)
    case inputItemList([SetappAI.SetappAIAPI.Responses.Input])
  }
}
extension SetappAI.SetappAIAPI.Responses.Instructions : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Instructions : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public struct LogProbabilities : Swift.Sendable, Swift.Decodable, Swift.Encodable, Swift.Equatable {
    public var bytes: [Swift.UInt8]
    public var logprob: Swift.Double
    public var token: Swift.String
    public var topLogprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities.LogProbability]
    public init(bytes: [Swift.UInt8], logprob: Swift.Double, token: Swift.String, topLogprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities.LogProbability])
    public static func == (a: SetappAI.SetappAIAPI.Responses.LogProbabilities, b: SetappAI.SetappAIAPI.Responses.LogProbabilities) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.LogProbabilities {
  public struct LogProbability : Swift.Sendable, Swift.Decodable, Swift.Encodable, Swift.Equatable {
    public var bytes: [Swift.UInt8]
    public var logprob: Swift.Double
    public var token: Swift.String
    public init(bytes: [Swift.UInt8], logprob: Swift.Double, token: Swift.String)
    public static func == (a: SetappAI.SetappAIAPI.Responses.LogProbabilities.LogProbability, b: SetappAI.SetappAIAPI.Responses.LogProbabilities.LogProbability) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Prompt : Swift.Sendable {
    public var id: Swift.String
    public var version: Swift.String?
    public var variables: [Swift.String : SetappAI.SetappAIAPI.Responses.Prompt.VariableValue]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, version: Swift.String?, variables: [Swift.String : SetappAI.SetappAIAPI.Responses.Prompt.VariableValue]?)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Prompt {
  public enum VariableValue : Swift.Sendable {
    case string(Swift.String)
    case input(SetappAI.SetappAIAPI.Responses.Input.Message.Content)
  }
}
extension SetappAI.SetappAIAPI.Responses.Prompt.VariableValue : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Prompt.VariableValue : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Prompt : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Prompt : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Reasoning : Swift.Sendable, Swift.Decodable, Swift.Encodable, Swift.Equatable {
    public let effort: SetappAI.SetappAIAPI.Responses.Reasoning.Effort?
    public let summary: SetappAI.SetappAIAPI.Responses.Reasoning.Summary?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(effort: SetappAI.SetappAIAPI.Responses.Reasoning.Effort? = .none, summary: SetappAI.SetappAIAPI.Responses.Reasoning.Summary? = .none)
    #endif
    public static func == (a: SetappAI.SetappAIAPI.Responses.Reasoning, b: SetappAI.SetappAIAPI.Responses.Reasoning) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Reasoning {
  public enum Effort : Swift.Sendable {
    public typealias RawValue = Swift.String
    case noEffort
    case minimal
    case low
    case medium
    case high
    case xHigh
    case unsupported(SetappAI.SetappAIAPI.Responses.Reasoning.Effort.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Reasoning.Effort : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Reasoning.Effort]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Reasoning.Effort.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Reasoning.Effort]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Effort.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Effort.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Effort.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Reasoning {
  public enum Summary : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case concise
    case detailed
    case unsupported(SetappAI.SetappAIAPI.Responses.Reasoning.Summary.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Reasoning.Summary : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Reasoning.Summary]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Reasoning.Summary.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Reasoning.Summary]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Summary.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Summary.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Reasoning.Summary.RawValue
}
extension SetappAI.SetappAIAPI.Responses {
  public enum ServiceTier : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case `default`
    case flex
    case priority
    case unsupported(SetappAI.SetappAIAPI.Responses.ServiceTier.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.ServiceTier : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.ServiceTier]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.ServiceTier]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.ServiceTier.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.ServiceTier.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.ServiceTier.RawValue
}
extension SetappAI.SetappAIAPI.Responses.ServiceTier : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ServiceTier : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Status : Swift.Sendable {
    public typealias RawValue = Swift.String
    case queued
    case inProgress
    case incomplete
    case completed
    case cancelled
    case failed
    case unsupported(SetappAI.SetappAIAPI.Responses.Status.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Status : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Status]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Status]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Status.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Status.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Status.RawValue
}
extension SetappAI.SetappAIAPI.Responses {
  public struct StreamOptions : Swift.Sendable, Swift.Encodable, Swift.Equatable, Swift.Decodable {
    public let includeObfuscation: Swift.Bool
    public init(includeObfuscation: Swift.Bool)
    public static func == (a: SetappAI.SetappAIAPI.Responses.StreamOptions, b: SetappAI.SetappAIAPI.Responses.StreamOptions) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Text : Swift.Sendable, Swift.Decodable, Swift.Encodable {
    public let format: SetappAI.SetappAIAPI.Responses.Text.Format
    public let verbosity: SetappAI.SetappAIAPI.Responses.Text.Verbosity?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(format: SetappAI.SetappAIAPI.Responses.Text.Format, verbosity: SetappAI.SetappAIAPI.Responses.Text.Verbosity?)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Text {
  public enum Format : Swift.Sendable {
    case text(SetappAI.SetappAIAPI.Responses.Text.TextFormat)
    case jsonObject(SetappAI.SetappAIAPI.Responses.Text.JSONObjectFormat)
    case jsonSchema(SetappAI.SetappAIAPI.Responses.Text.JSONSchemaFormat)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Text.TextType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Text.Format : SetappAI.TextFormatProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Text.TextType {
    get
  }
  @inlinable @inline(__always) internal var object: any SetappAI.TextFormatProtocol {
    get {
        switch self {
        case let .text(text):
            text
        case let .jsonObject(jsonObject):
            jsonObject
        case let .jsonSchema(jsonSchema):
            jsonSchema
        case let .unsupported(unsupported):
            unsupported
        }
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Text.Format : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Text.Format : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Text {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func text(verbosity: SetappAI.SetappAIAPI.Responses.Text.Verbosity?) -> SetappAI.SetappAIAPI.Responses.Text
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func jsonObject(verbosity: SetappAI.SetappAIAPI.Responses.Text.Verbosity?) -> SetappAI.SetappAIAPI.Responses.Text
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func jsonSchema(name: Swift.String, schema: [Swift.String : any Swift.Sendable], description: Swift.String? = .none, strict: Swift.Bool = false, verbosity: SetappAI.SetappAIAPI.Responses.Text.Verbosity?) -> SetappAI.SetappAIAPI.Responses.Text
  #endif
}
public protocol TextFormatProtocol : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Text.TextType { get }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.TextFormatProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Text.TextType {
}
extension SetappAI.SetappAIAPI.Responses.Text {
  public struct TextFormat : SetappAI.TextFormatProtocol, Swift.Equatable {
    public var type: SetappAI.SetappAIAPI.Responses.Text.TextType {
      get
    }
    public init()
    public static func == (a: SetappAI.SetappAIAPI.Responses.Text.TextFormat, b: SetappAI.SetappAIAPI.Responses.Text.TextFormat) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct JSONObjectFormat : SetappAI.TextFormatProtocol, Swift.Equatable {
    public var type: SetappAI.SetappAIAPI.Responses.Text.TextType {
      get
    }
    public init()
    public static func == (a: SetappAI.SetappAIAPI.Responses.Text.JSONObjectFormat, b: SetappAI.SetappAIAPI.Responses.Text.JSONObjectFormat) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct JSONSchemaFormat : SetappAI.TextFormatProtocol, Swift.Sendable {
    public var type: SetappAI.SetappAIAPI.Responses.Text.TextType {
      get
    }
    public let name: Swift.String
    public let schema: [Swift.String : any Swift.Sendable]
    public let description: Swift.String?
    public let strict: Swift.Bool
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, schema: [Swift.String : any Swift.Sendable], description: Swift.String?, strict: Swift.Bool = false)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Text.JSONSchemaFormat : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Text.JSONSchemaFormat : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Text {
  public enum Verbosity : Swift.Sendable {
    public typealias RawValue = Swift.String
    case low
    case medium
    case high
    case unsupported(SetappAI.SetappAIAPI.Responses.Text.Verbosity.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Text.Verbosity : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Text.Verbosity]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Text.Verbosity]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Text.Verbosity.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Text.Verbosity.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Text.Verbosity.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Text {
  public enum TextType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case text
    case jsonObject
    case jsonSchema
    case unsupported(SetappAI.SetappAIAPI.Responses.Text.TextType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Text.TextType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Text.TextType]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Text.TextType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Text.TextType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Text.TextType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Text.TextType.RawValue
}
extension SetappAI.SetappAIAPI.Responses {
  public enum ToolChoice : Swift.Sendable {
    case options(SetappAI.SetappAIAPI.Responses.ToolChoice.Options)
    case allowed(SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed)
    case builtIn(SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn)
    case function(SetappAI.SetappAIAPI.Responses.ToolChoice.Function)
    case mcp(SetappAI.SetappAIAPI.Responses.ToolChoice.MCP)
    case custom(SetappAI.SetappAIAPI.Responses.ToolChoice.Custom)
    case applyPatch(SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch)
    case shell(SetappAI.SetappAIAPI.Responses.ToolChoice.Shell)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public static var none: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var auto: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var required: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var fileSearch: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var webSearch: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var computerUsePreview: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var imageGeneration: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var codeInterpreter: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func mcp(serverLabel: Swift.String, name: Swift.String? = .none) -> SetappAI.SetappAIAPI.Responses.ToolChoice
  #endif
  public static func custom(name: Swift.String) -> SetappAI.SetappAIAPI.Responses.ToolChoice
  public static var applyPatch: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
  public static var shell: SetappAI.SetappAIAPI.Responses.ToolChoice {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Truncation : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case disabled
    case unsupported(SetappAI.SetappAIAPI.Responses.Truncation.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Truncation : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Truncation]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Truncation]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Truncation.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Truncation.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Truncation.RawValue
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Usage : Swift.Sendable, Swift.Equatable, Swift.Decodable {
    public var totalTokens: Swift.Int
    public var inputTokens: Swift.Int
    public var inputTokensDetails: SetappAI.SetappAIAPI.Responses.Usage.InputTokensDetails
    public var outputTokens: Swift.Int
    public var outputTokensDetails: SetappAI.SetappAIAPI.Responses.Usage.OutputTokensDetails
    public init(totalTokens: Swift.Int, inputTokens: Swift.Int, inputTokensDetails: SetappAI.SetappAIAPI.Responses.Usage.InputTokensDetails, outputTokens: Swift.Int, outputTokensDetails: SetappAI.SetappAIAPI.Responses.Usage.OutputTokensDetails)
    public static func == (a: SetappAI.SetappAIAPI.Responses.Usage, b: SetappAI.SetappAIAPI.Responses.Usage) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Usage {
  public struct InputTokensDetails : Swift.Sendable, Swift.Equatable, Swift.Decodable {
    public var cachedTokens: Swift.Int
    public init(cachedTokens: Swift.Int)
    public static func == (a: SetappAI.SetappAIAPI.Responses.Usage.InputTokensDetails, b: SetappAI.SetappAIAPI.Responses.Usage.InputTokensDetails) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Usage {
  public struct OutputTokensDetails : Swift.Sendable, Swift.Equatable, Swift.Decodable {
    public var reasoningTokens: Swift.Int
    public init(reasoningTokens: Swift.Int)
    public static func == (a: SetappAI.SetappAIAPI.Responses.Usage.OutputTokensDetails, b: SetappAI.SetappAIAPI.Responses.Usage.OutputTokensDetails) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed {
  public enum Tool : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    case builtIn(SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn)
    case function(SetappAI.SetappAIAPI.Responses.ToolChoice.Function)
    case mcp(SetappAI.SetappAIAPI.Responses.ToolChoice.MCP)
    case custom(SetappAI.SetappAIAPI.Responses.ToolChoice.Custom)
    case applyPatch(SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch)
    case shell(SetappAI.SetappAIAPI.Responses.ToolChoice.Shell)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType>)
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool, b: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func mcp(serverLabel: Swift.String, name: Swift.String? = .none) -> SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool
  #endif
  public static func function(name: Swift.String) -> SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool
  public static func custom(name: Swift.String) -> SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool
  public static var applyPatch: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var shell: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var fileSearch: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var webSearch: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var computerUsePreview: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var codeInterpreter: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
  public static var imageGeneration: SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct Allowed : Swift.Sendable {
    public var mode: SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode
    public var tools: [SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool]
    public init(mode: SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode, tools: [SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool])
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public enum AllowedMode : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case required
    case unsupported(SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode]
  public var rawValue: SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode.RawValue
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct ApplyPatch : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public init()
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch, b: SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
  public enum BuiltInType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case fileSearch
    case webSearch
    case computerUsePreview
    case codeInterpreter
    case imageGeneration
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.CaseIterable {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType]
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType]
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.RawRepresentable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public var rawValue: Swift.String {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.Equatable {
  public static func == (lhs: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType, rhs: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType) -> Swift.Bool
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct BuiltIn : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType
    public init(type: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType)
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn, b: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
  public static var imageGeneration: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
    get
  }
  public static var codeInterpreter: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
    get
  }
  public static var fileSearch: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
    get
  }
  public static var webSearch: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
    get
  }
  public static var computerUsePreview: SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct Custom : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public var name: Swift.String
    public init(name: Swift.String)
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.Custom, b: SetappAI.SetappAIAPI.Responses.ToolChoice.Custom) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Custom {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Custom : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Custom : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct Function : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public var name: Swift.String
    public init(name: Swift.String)
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.Function, b: SetappAI.SetappAIAPI.Responses.ToolChoice.Function) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Function {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Function : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Function : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct MCP : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public var serverLabel: Swift.String
    public var name: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(serverLabel: Swift.String, name: Swift.String? = .none)
    #endif
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.MCP, b: SetappAI.SetappAIAPI.Responses.ToolChoice.MCP) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.MCP {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.MCP : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.MCP : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public enum Options : Swift.Sendable {
    public typealias RawValue = Swift.String
    case none
    case auto
    case required
    case unsupported(SetappAI.SetappAIAPI.Responses.ToolChoice.Options.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Options : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.ToolChoice.Options]
  public var rawValue: SetappAI.SetappAIAPI.Responses.ToolChoice.Options.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.ToolChoice.Options]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.Options.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.Options.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.Options.RawValue
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public struct Shell : Swift.Sendable, Swift.Equatable, Swift.Hashable {
    public init()
    public static func == (a: SetappAI.SetappAIAPI.Responses.ToolChoice.Shell, b: SetappAI.SetappAIAPI.Responses.ToolChoice.Shell) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Shell {
  public var type: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Shell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.Shell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice {
  public enum ToolChoiceType : Swift.Sendable, Swift.Hashable {
    public typealias RawValue = Swift.String
    case allowedTools
    case function
    case mcp
    case custom
    case applyPatch
    case shell
    case builtIn(SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType)
    case unsupported(SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public struct CompactionItem : Swift.Sendable {
    public var id: Swift.String
    public var encryptedContent: Swift.String
    public var createdBy: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, encryptedContent: Swift.String, createdBy: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.CompactionItem : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.CompactionItem : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.CompactionItem : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public struct MCPApprovalRequest : Swift.Sendable {
    public var id: Swift.String
    public var arguments: Swift.String
    public var name: Swift.String
    public var serverLabel: Swift.String
    public init(id: Swift.String, arguments: Swift.String, name: Swift.String, serverLabel: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPApprovalRequest : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPApprovalRequest : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPApprovalRequest : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public struct MCPListTools : Swift.Sendable {
    public var id: Swift.String
    public var serverLabel: Swift.String
    public var tools: [SetappAI.SetappAIAPI.Responses.Output.MCPListTools.Tool]
    public var error: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, serverLabel: Swift.String, tools: [SetappAI.SetappAIAPI.Responses.Output.MCPListTools.Tool], error: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools {
  public struct Tool : Swift.Sendable {
    public var name: Swift.String
    public var inputSchema: [Swift.String : any Swift.Sendable]
    public var description: Swift.String?
    public var annotations: (any Swift.Sendable)?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, inputSchema: [Swift.String : any Swift.Sendable], description: Swift.String? = nil, annotations: (any Swift.Sendable)? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools.Tool : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools.Tool : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.MCPListTools : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ModelOutputMessageContentProtocol : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType { get }
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public struct Message {
    public var id: Swift.String
    public var content: [SetappAI.SetappAIAPI.Responses.Output.Message.Content]
    public var role: SetappAI.SetappAIAPI.Responses.Role
    public var status: SetappAI.SetappAIAPI.Responses.Output.Message.Status
    public init(id: Swift.String, content: [SetappAI.SetappAIAPI.Responses.Output.Message.Content], role: SetappAI.SetappAIAPI.Responses.Role, status: SetappAI.SetappAIAPI.Responses.Output.Message.Status)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message {
  public typealias Status = SetappAI.SetappAIAPI.Responses.Input.Message.Status
}
extension SetappAI.SetappAIAPI.Responses.Output.Message {
  public enum Content {
    case text(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text)
    case refusal(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Refusal)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType>)
  }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.ModelOutputMessageContentProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType {
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content {
  public enum ContentType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case outputText
    case refusal
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content : SetappAI.ModelOutputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType {
    get
  }
  @inlinable @inline(__always) public var object: any SetappAI.ModelOutputMessageContentProtocol {
    get {
        switch self {
        case let .text(text): text
        case let .refusal(refusal): refusal
        case let .unsupported(unsupported): unsupported
        }
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation {
  public struct ContainerFileCitation {
    public var containerID: Swift.String
    public var fileID: Swift.String
    public var filename: Swift.String
    public var starIndex: Swift.Int
    public var endIndex: Swift.Int
    public init(containerID: Swift.String, fileID: Swift.String, filename: Swift.String, starIndex: Swift.Int, endIndex: Swift.Int)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.ContainerFileCitation : SetappAI.ModelOutputMessageAnnotationProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.ContainerFileCitation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.ContainerFileCitation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation {
  public struct FileCitation {
    public var fileID: Swift.String
    public var filename: Swift.String
    public var index: Swift.Int
    public init(fileID: Swift.String, filename: Swift.String, index: Swift.Int)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FileCitation : SetappAI.ModelOutputMessageAnnotationProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FileCitation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FileCitation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation {
  public struct FilePath {
    public var fileID: Swift.String
    public var index: Swift.Int
    public init(fileID: Swift.String, index: Swift.Int)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FilePath : SetappAI.ModelOutputMessageAnnotationProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FilePath : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FilePath : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation {
  public struct URLCitation {
    public var url: Foundation.URL
    public var title: Swift.String
    public var starIndex: Swift.Int
    public var endIndex: Swift.Int
    public init(url: Foundation.URL, title: Swift.String, starIndex: Swift.Int, endIndex: Swift.Int)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.URLCitation : SetappAI.ModelOutputMessageAnnotationProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.URLCitation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.URLCitation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content {
  public struct Refusal : Swift.Sendable {
    public var refusal: Swift.String
    public init(refusal: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Refusal : SetappAI.ModelOutputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Refusal : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Refusal : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text {
  public enum Annotation : Swift.Sendable {
    case fileCitation(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FileCitation)
    case urlCitation(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.URLCitation)
    case containerFileCitation(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.ContainerFileCitation)
    case filePath(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.FilePath)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType>)
  }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.ModelOutputMessageAnnotationProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation : SetappAI.ModelOutputMessageAnnotationProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType {
    get
  }
  @inlinable @inline(__always) internal var object: any SetappAI.ModelOutputMessageAnnotationProtocol {
    get {
        switch self {
        case let .fileCitation(fileCitation):
            fileCitation
        case let .urlCitation(urlCitation):
            urlCitation
        case let .containerFileCitation(containerFileCitation):
            containerFileCitation
        case let .filePath(filePath):
            filePath
        case let .unsupported(unsupported):
            unsupported
        }
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation {
  public enum AnnotationType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case fileCitation
    case urlCitation
    case containerFileCitation
    case filePath
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content {
  public struct Text : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var text: Swift.String
    public var annotations: [SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation]
    public var logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities]
    public init(text: Swift.String, annotations: [SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation], logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public protocol ModelOutputMessageAnnotationProtocol : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation.AnnotationType { get }
}
extension SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text : SetappAI.ModelOutputMessageContentProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.Message.Content.ContentType {
    get
  }
}
public protocol ModelOutputProtocol : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Output.OutputType { get }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.ModelOutputProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Output.OutputType {
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Output {
    case message(SetappAI.SetappAIAPI.Responses.Output.Message)
    case toolCall(SetappAI.SetappAIAPI.Responses.Output.ToolCall)
    case toolOutput(SetappAI.SetappAIAPI.Responses.Output.ToolOutput)
    case mcpApprovalRequest(SetappAI.SetappAIAPI.Responses.Output.MCPApprovalRequest)
    case compactionItem(SetappAI.SetappAIAPI.Responses.Output.CompactionItem)
    case reasoning(SetappAI.SetappAIAPI.Responses.Output.ReasoningItem)
    case mcpListTools(SetappAI.SetappAIAPI.Responses.Output.MCPListTools)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.OutputType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public enum OutputType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case message
    case toolCall(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType)
    case toolOutput(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType)
    case mcpApprovalRequest
    case compactionItem
    case reasoning
    case mcpListTools
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.OutputType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.OutputType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.OutputType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.OutputType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.OutputType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.OutputType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.OutputType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.OutputType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public struct ReasoningItem : Swift.Sendable {
    public var id: Swift.String
    public var summary: [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.SummaryTextContent]
    public var content: [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.ReasoningTextContent]?
    public var encryptedContent: Swift.String?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, summary: [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.SummaryTextContent], content: [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.ReasoningTextContent]? = nil, encryptedContent: Swift.String? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem {
  public struct SummaryTextContent : Swift.Sendable {
    public var text: Swift.String
    public var type: Swift.String {
      get
    }
    public init(text: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.SummaryTextContent : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.SummaryTextContent : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem {
  public struct ReasoningTextContent : Swift.Sendable {
    public var text: Swift.String
    public var type: Swift.String {
      get
    }
    public init(text: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.ReasoningTextContent : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.ReasoningTextContent : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case incomplete
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem : SetappAI.ModelOutputProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation {
  public struct CreateFile : Swift.Sendable {
    public var path: Swift.String
    public var diff: Swift.String
    public init(path: Swift.String, diff: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.CreateFile {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.CreateFile : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.CreateFile : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation {
  public struct DeleteFile : Swift.Sendable {
    public var path: Swift.String
    public init(path: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.DeleteFile {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.DeleteFile : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.DeleteFile : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation {
  public struct UpdateFile : Swift.Sendable {
    public var path: Swift.String
    public var diff: Swift.String
    public init(path: Swift.String, diff: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.UpdateFile {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.UpdateFile : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.UpdateFile : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch {
  public enum Operation : Swift.Sendable {
    case createFile(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.CreateFile)
    case deleteFile(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.DeleteFile)
    case updateFile(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.UpdateFile)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation {
  public enum OperationType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case createFile
    case deleteFile
    case updateFile
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.OperationType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output {
  public struct Image : Swift.Sendable {
    public var url: Swift.String
    public init(url: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Image {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Image : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Image : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output {
  public struct Logs : Swift.Sendable {
    public var logs: Swift.String
    public init(logs: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Logs {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Logs : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Logs : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter {
  public enum Output : Swift.Sendable {
    case logs(SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Logs)
    case image(SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Image)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output {
  public enum OutputType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case logs
    case image
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.OutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case incomplete
    case interpreting
    case failed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Click : Swift.Sendable {
    public var button: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button
    public var x: Swift.Double
    public var y: Swift.Double
    public init(button: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button, x: Swift.Double, y: Swift.Double)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click {
  public enum Button : Swift.Sendable {
    public typealias RawValue = Swift.String
    case left
    case right
    case wheel
    case back
    case forward
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click.Button.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct DoubleClick : Swift.Sendable {
    public var x: Swift.Double
    public var y: Swift.Double
    public init(x: Swift.Double, y: Swift.Double)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.DoubleClick {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.DoubleClick : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.DoubleClick : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Drag : Swift.Sendable {
    public var path: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag.Point]
    public init(path: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag.Point])
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag {
  public struct Point : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var x: Swift.Double
    public var y: Swift.Double
    public init(x: Swift.Double, y: Swift.Double)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Keypress : Swift.Sendable {
    public var keys: [Swift.String]
    public init(keys: [Swift.String])
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Keypress {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Keypress : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Keypress : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Move : Swift.Sendable {
    public var x: Swift.Double
    public var y: Swift.Double
    public init(x: Swift.Double, y: Swift.Double)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Move {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Move : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Move : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Screenshot : Swift.Sendable {
    public init()
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Screenshot {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Screenshot : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Screenshot : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Scroll : Swift.Sendable {
    public var x: Swift.Double
    public var y: Swift.Double
    public var scrollX: Swift.Double
    public var scrollY: Swift.Double
    public init(x: Swift.Double, y: Swift.Double, scrollX: Swift.Double, scrollY: Swift.Double)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Scroll {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Scroll : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Scroll : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct TypeText : Swift.Sendable {
    public var text: Swift.String
    public init(text: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.TypeText {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.TypeText : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.TypeText : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public struct Wait : Swift.Sendable {
    public init()
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Wait {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Wait : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Wait : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer {
  public enum Action : Swift.Sendable {
    case click(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Click)
    case doubleClick(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.DoubleClick)
    case drag(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Drag)
    case keypress(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Keypress)
    case move(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Move)
    case screenshot(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Screenshot)
    case scroll(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Scroll)
    case type(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.TypeText)
    case wait(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.Wait)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action {
  public enum ActionType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case click
    case doubleClick
    case drag
    case keypress
    case move
    case screenshot
    case scroll
    case type
    case wait
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action.ActionType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer {
  public struct SafetyCheck : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var id: Swift.String
    public var code: Swift.String?
    public var message: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, code: Swift.String? = nil, message: Swift.String? = nil)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case incomplete
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch {
  public struct Result : Swift.Sendable {
    public var fileID: Swift.String?
    public var filename: Swift.String?
    public var score: Swift.Double?
    public var text: Swift.String?
    public var attributes: [Swift.String : any Swift.Sendable]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fileID: Swift.String? = nil, filename: Swift.String? = nil, score: Swift.Double? = nil, text: Swift.String? = nil, attributes: [Swift.String : any Swift.Sendable]? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Result : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Result : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case searching
    case completed
    case incomplete
    case failed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell {
  public struct Action : Swift.Sendable {
    public var command: [Swift.String]
    public var env: [Swift.String : Swift.String]?
    public var type: Swift.String {
      get
    }
    public var timeoutMs: Swift.Int?
    public var user: Swift.String?
    public var workingDirectory: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(command: [Swift.String], env: [Swift.String : Swift.String]? = nil, timeoutMs: Swift.Int? = nil, user: Swift.String? = nil, workingDirectory: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Action : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Action : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case failed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct ApplyPatch : Swift.Sendable {
    public var operation: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation
    public var callID: Swift.String
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status
    public var id: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(operation: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation, callID: Swift.String, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status, id: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct CodeInterpreter : Swift.Sendable {
    public var id: Swift.String
    public var code: Swift.String?
    public var containerID: Swift.String
    public var outputs: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output]?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, code: Swift.String? = nil, containerID: Swift.String, outputs: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output]? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct Computer : Swift.Sendable {
    public var action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action
    public var callID: Swift.String
    public var pendingSafetyChecks: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.SafetyCheck]?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status?
    public var id: Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public init(action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Action, callID: Swift.String, pendingSafetyChecks: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.SafetyCheck]? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status? = nil, id: Swift.String)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct Custom : Swift.Sendable {
    public var name: Swift.String
    public var callID: Swift.String
    public var input: Swift.String
    public var id: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, callID: Swift.String, input: Swift.String, id: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Custom {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Custom : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Custom : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct FileSearch : Swift.Sendable {
    public var id: Swift.String
    public var queries: [Swift.String]
    public var results: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Result]?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, queries: [Swift.String], results: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Result]? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct Function : Swift.Sendable {
    public var name: Swift.String
    public var arguments: Swift.String
    public var callID: Swift.String
    public var id: Swift.String?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, arguments: Swift.String, callID: Swift.String, id: Swift.String? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    public typealias RawValue = Swift.String
    case inProgress
    case completed
    case incomplete
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status]
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct ImageGeneration : Swift.Sendable {
    public var id: Swift.String
    public var result: Swift.String
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status
    public init(id: Swift.String, result: Swift.String, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case generating
    case failed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct LocalShell : Swift.Sendable {
    public var id: Swift.String
    public var action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Action
    public var callID: Swift.String
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Action, callID: Swift.String, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct MCP : Swift.Sendable {
    public var id: Swift.String
    public var name: Swift.String
    public var arguments: Swift.String
    public var serverLabel: Swift.String
    public var approvalRequestID: Swift.String?
    public var output: Swift.String?
    public var error: Swift.String?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, name: Swift.String, arguments: Swift.String, serverLabel: Swift.String, approvalRequestID: Swift.String? = nil, output: Swift.String? = nil, error: Swift.String? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case failed
    case incomplete
    case calling
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct Shell : Swift.Sendable {
    public var action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell.Action
    public var callID: Swift.String
    public var id: Swift.String?
    public var environment: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell.Action, callID: Swift.String, id: Swift.String? = nil, environment: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell {
  public struct Action : Swift.Sendable, Swift.Codable {
    public var commands: [Swift.String]
    public var maxOutputLength: Swift.Int?
    public var timeoutMs: Swift.Int?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(commands: [Swift.String], maxOutputLength: Swift.Int? = nil, timeoutMs: Swift.Int? = nil)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public enum ToolCallType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case fileSearch
    case function
    case computer
    case imageGeneration
    case codeInterpreter
    case localShell
    case shell
    case applyPatch
    case mcp
    case custom
    case webSearch
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public struct WebSearch : Swift.Sendable {
    public var id: Swift.String
    public var action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, action: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public enum ToolCall : Swift.Sendable {
    case fileSearch(SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch)
    case function(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function)
    case computer(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer)
    case imageGeneration(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration)
    case codeInterpreter(SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter)
    case localShell(SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell)
    case shell(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell)
    case applyPatch(SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch)
    case mcp(SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP)
    case custom(SetappAI.SetappAIAPI.Responses.Output.ToolCall.Custom)
    case webSearch(SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.ToolCallType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action {
  public struct FindInPage : Swift.Sendable {
    public var url: Swift.String
    public var pattern: Swift.String
    public init(url: Swift.String, pattern: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.FindInPage {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.FindInPage : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.FindInPage : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action {
  public struct OpenPage : Swift.Sendable {
    public var url: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(url: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.OpenPage {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.OpenPage : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.OpenPage : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action {
  public struct Search : Swift.Sendable {
    public var queries: [Swift.String]?
    public var sources: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search.Source]?
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(queries: [Swift.String]? = nil, sources: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search.Source]? = nil)
  #endif
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search {
  public struct Source : Swift.Sendable {
    public var url: Swift.String
    public var type: Swift.String {
      get
    }
    public init(url: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search.Source : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search.Source : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch {
  public enum Action : Swift.Sendable {
    case search(SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search)
    case openPage(SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.OpenPage)
    case findInPage(SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.FindInPage)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action {
  public enum ActionType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case search
    case openPage
    case findInPage
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.ActionType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    public typealias RawValue = Swift.String
    case inProgress
    case searching
    case completed
    case failed
    case incomplete
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status]
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct ApplyPatch : Swift.Sendable {
    public var callID: Swift.String
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status
    public var id: Swift.String?
    public var output: Swift.String?
    public var createdBy: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(callID: Swift.String, status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status, id: Swift.String? = nil, output: Swift.String? = nil, createdBy: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case completed
    case failed
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct Computer : Swift.Sendable {
    public typealias SafetyCheck = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.SafetyCheck
    public typealias Status = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status
    public var callID: Swift.String
    public var output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Screenshot
    public var id: Swift.String?
    public var acknowledgedSafetyChecks: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.SafetyCheck]?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(callID: Swift.String, output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Screenshot, id: Swift.String? = nil, acknowledgedSafetyChecks: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.SafetyCheck]? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer {
  public struct Screenshot : Swift.Sendable {
    public var fileID: Swift.String?
    public var imageURL: Swift.String?
    public var type: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fileID: Swift.String? = nil, imageURL: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Screenshot : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Screenshot : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct Custom : Swift.Sendable {
    public typealias OutputContent = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.OutputContent
    public var callID: Swift.String
    public var output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom.OutputContent
    public var id: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(callID: Swift.String, output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom.OutputContent, id: Swift.String? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct Function : Swift.Sendable {
    public typealias OutputContent = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.OutputContent
    public typealias Status = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status
    public var callID: Swift.String
    public var output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function.OutputContent
    public var id: Swift.String?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(callID: Swift.String, output: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function.OutputContent, id: Swift.String? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct LocalShell : Swift.Sendable {
    public typealias Status = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status
    public var id: Swift.String
    public var output: Swift.String
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String, output: Swift.String, status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public enum OutputContent : Swift.Sendable {
    case string(Swift.String)
    case content([SetappAI.SetappAIAPI.Responses.Input.Message.Content])
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.OutputContent : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.OutputContent : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public struct Shell : Swift.Sendable {
    public typealias Status = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status
    public var callID: Swift.String
    public var output: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.OutputChunk]
    public var id: Swift.String?
    public var maxOutputLength: Swift.Int?
    public var status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.Status?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(callID: Swift.String, output: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.OutputChunk], id: Swift.String? = nil, maxOutputLength: Swift.Int? = nil, status: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.Status? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell {
  public struct OutputChunk : Swift.Sendable, Swift.Codable {
    public var outcome: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.Outcome
    public var stderr: Swift.String
    public var stdout: Swift.String
    public init(outcome: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.Outcome, stderr: Swift.String, stdout: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell {
  public enum Outcome : Swift.Sendable {
    case timeout
    case exit(exitCode: Swift.Int)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell.Outcome : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public enum Status : Swift.String, Swift.CaseIterable, Swift.Sendable, Swift.Codable {
    case inProgress
    case completed
    case incomplete
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public enum ToolOutputType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case computer
    case function
    case localShell
    case shell
    case applyPatch
    case custom
    case unsupported(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Output {
  public enum ToolOutput : Swift.Sendable {
    case computer(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer)
    case function(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function)
    case localShell(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell)
    case shell(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell)
    case applyPatch(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch)
    case custom(SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput {
  public var type: SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ToolOutputType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI {
  public struct UnsupportedObject<ObjectType> : Swift.Sendable where ObjectType : Swift.Sendable {
    public let type: ObjectType
    public let object: [Swift.String : any Swift.Sendable]
    public init(type: ObjectType, object: [Swift.String : any Swift.Sendable])
  }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : Swift.Encodable where ObjectType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.UnsupportedObject : Swift.Decodable where ObjectType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.UnsupportedObject : Swift.Equatable {
  public static func == (_: SetappAI.SetappAIAPI.UnsupportedObject<ObjectType>, _: SetappAI.SetappAIAPI.UnsupportedObject<ObjectType>) -> Swift.Bool
}
extension SetappAI.SetappAIAPI.UnsupportedObject : Swift.Hashable where ObjectType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public struct Response : Swift.Sendable {
    public var id: Swift.String
    public var model: Swift.String
    public var object: Swift.String {
      get
    }
    public var status: SetappAI.SetappAIAPI.Responses.Status
    public var createdAt: Foundation.Date
    public var completedAt: Foundation.Date?
    public var incompleteDetails: SetappAI.SetappAIAPI.Responses.IncompleteDetails?
    public var instructions: SetappAI.SetappAIAPI.Responses.Instructions?
    public var output: [SetappAI.SetappAIAPI.Responses.Output]?
    public var toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice?
    public var tools: [SetappAI.SetappAIAPI.Responses.Tool]?
    public var usage: SetappAI.SetappAIAPI.Responses.Usage?
    public var maxOutputTokens: Swift.Int?
    public var maxToolCalls: Swift.Int?
    public var parallelToolCalls: Swift.Bool
    public var previousResponseID: Swift.String?
    public var prompt: SetappAI.SetappAIAPI.Responses.Prompt?
    public var promptCacheKey: Swift.String?
    public var promptCacheRetention: Swift.String?
    public var reasoning: SetappAI.SetappAIAPI.Responses.Reasoning?
    public var serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier?
    public var temperature: Swift.Double?
    public var text: SetappAI.SetappAIAPI.Responses.Text?
    public var logprobs: Swift.Int?
    public var topP: Swift.Double?
    public var truncation: SetappAI.SetappAIAPI.Responses.Truncation?
    public var metadata: [Swift.String : Swift.String]?
    public var error: SetappAI.SetappAIAPI.Responses.Error?
    public var background: Swift.Bool?
  }
}
extension SetappAI.SetappAIAPI.Responses.Response : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Response {
  #if compiler(>=5.3) && $NonescapableTypes
  public var outputText: Swift.String? {
    get
  }
  #endif
}
extension SetappAI.SetappAIAPI.Responses {
  public struct DeletedResponse : Swift.Sendable, Swift.Decodable {
    public var id: Swift.String
    public var object: Swift.String
    public var deleted: Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Role : Swift.Sendable {
    public typealias RawValue = Swift.String
    case user
    case assistant
    case system
    case developer
    case unsupported(SetappAI.SetappAIAPI.Responses.Role.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Role : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Role]
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Role]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Role.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Role.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Role.RawValue
}
public protocol SetappAIResponsesToolProtocol : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType { get }
}
extension SetappAI.SetappAIAPI.Responses {
  public enum Tool : Swift.Sendable {
    case function(SetappAI.SetappAIAPI.Responses.Tool.Function)
    case fileSearch(SetappAI.SetappAIAPI.Responses.Tool.FileSearch)
    case computer(SetappAI.SetappAIAPI.Responses.Tool.Computer)
    case webSearch(SetappAI.SetappAIAPI.Responses.Tool.WebSearch)
    case mcp(SetappAI.SetappAIAPI.Responses.Tool.MCP)
    case codeInterpreter(SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter)
    case imageGeneration(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration)
    case applyPatch(SetappAI.SetappAIAPI.Responses.Tool.ApplyPatch)
    case localShell(SetappAI.SetappAIAPI.Responses.Tool.LocalShell)
    case functionShell(SetappAI.SetappAIAPI.Responses.Tool.FunctionShellTool)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Tool.ToolType>)
  }
}
extension SetappAI.SetappAIAPI.UnsupportedObject : SetappAI.SetappAIResponsesToolProtocol where ObjectType == SetappAI.SetappAIAPI.Responses.Tool.ToolType {
}
extension SetappAI.SetappAIAPI.Responses.Tool : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public enum ToolType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case function
    case fileSearch
    case computer
    case webSearch
    case webSearch_2025_08_26
    case mcp
    case codeInterpreter
    case imageGeneration
    case localShell
    case functionShell
    case custom
    case applyPatch
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ToolType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ToolType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ToolType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ToolType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ToolType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ToolType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ToolType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ToolType.RawValue
}
public protocol SetappAIResponsesAPIProtocol : Swift.Sendable {
  var inputItems: any SetappAI.SetappAIResponsesInputItemsAPIProtocol { get }
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func create(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters, timeoutInterval: Foundation.TimeInterval) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func createBackground(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func createStream(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func get(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.GetResponseParameters) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func getStream(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.GetResponseParameters) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func cancel(id: Swift.String) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func delete(id: Swift.String) async throws -> SetappAI.SetappAIAPI.Responses.DeletedResponse
  #endif
}
extension SetappAI.SetappAIResponsesAPIProtocol {
  #if compiler(>=5.3) && $NonescapableTypes && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func createStream(model: SetappAI.SetappAIAPI.Model, input: [SetappAI.SetappAIAPI.Responses.Input], instructions: Swift.String? = .none, contextManagement: SetappAI.SetappAIAPI.Responses.ContextManagement? = nil, reasoning: SetappAI.SetappAIAPI.Responses.Reasoning? = .none, previousResponseID: Swift.String? = .none, text: SetappAI.SetappAIAPI.Responses.Text? = .none, include: [SetappAI.SetappAIAPI.Responses.Include]? = .none, tools: [SetappAI.SetappAIAPI.Responses.Tool]? = nil, toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice? = nil, maxToolCalls: Swift.Int? = .none, parallelToolCalls: Swift.Bool? = .none, serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier? = nil, store: Swift.Bool? = .none, truncation: SetappAI.SetappAIAPI.Responses.Truncation? = .none, metadata: [Swift.String : Swift.String]? = .none, maxOutputTokens: Swift.Int? = .none, temperature: Swift.Double? = .none, topP: Swift.Double? = .none, topLogprobs: Swift.Int? = .none, streamOptions: SetappAI.SetappAIAPI.Responses.StreamOptions? = .none) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func createStream(model: SetappAI.SetappAIAPI.Model, input: [any SetappAI.ModelInputProtocol], instructions: Swift.String? = .none, contextManagement: SetappAI.SetappAIAPI.Responses.ContextManagement? = nil, reasoning: SetappAI.SetappAIAPI.Responses.Reasoning? = .none, previousResponseID: Swift.String? = .none, text: SetappAI.SetappAIAPI.Responses.Text? = .none, include: [SetappAI.SetappAIAPI.Responses.Include]? = .none, tools: [any SetappAI.SetappAIResponsesToolProtocol]? = nil, toolChoice: SetappAI.SetappAIAPI.Responses.ToolChoice? = nil, maxToolCalls: Swift.Int? = .none, parallelToolCalls: Swift.Bool? = .none, serviceTier: SetappAI.SetappAIAPI.Responses.ServiceTier? = nil, store: Swift.Bool? = .none, truncation: SetappAI.SetappAIAPI.Responses.Truncation? = .none, metadata: [Swift.String : Swift.String]? = .none, maxOutputTokens: Swift.Int? = .none, temperature: Swift.Double? = .none, topP: Swift.Double? = .none, topLogprobs: Swift.Int? = .none, streamOptions: SetappAI.SetappAIAPI.Responses.StreamOptions? = .none) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
}
extension SetappAI.SetappAIAPI {
  public struct Responses {
  }
}
extension SetappAI.SetappAIAPI.Responses : SetappAI.SetappAIResponsesAPIProtocol {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func create(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters, timeoutInterval: Foundation.TimeInterval) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func createBackground(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func createStream(parameters: SetappAI.SetappAIAPI.Responses.CreateRequestParameters) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func get(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.GetResponseParameters) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func getStream(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.GetResponseParameters) async throws -> SetappAI.CancellableAsyncStream<SetappAI.SetappAIAPI.StreamingEvent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func delete(id: Swift.String) async throws -> SetappAI.SetappAIAPI.Responses.DeletedResponse
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func cancel(id: Swift.String) async throws -> SetappAI.SetappAIAPI.Responses.Response
  #endif
  public var inputItems: any SetappAI.SetappAIResponsesInputItemsAPIProtocol {
    get
  }
}
public protocol SetappAIResponsesInputItemsAPIProtocol : Swift.Sendable {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) func list(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.InputItems.GetInputItemsParameters) async throws -> SetappAI.SetappAIAPI.Responses.InputItems.List
  #endif
}
extension SetappAI.SetappAIAPI.Responses {
  public struct InputItems {
  }
}
extension SetappAI.SetappAIAPI.Responses.InputItems : SetappAI.SetappAIResponsesInputItemsAPIProtocol {
  public typealias List = SetappAI.SetappAIAPI.List<SetappAI.SetappAIAPI.Responses.Input>
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func list(id: Swift.String, parameters: SetappAI.SetappAIAPI.Responses.InputItems.GetInputItemsParameters) async throws -> SetappAI.SetappAIAPI.Responses.InputItems.List
  #endif
}
extension SetappAI.SetappAIAPI.Responses.InputItems {
  public struct GetInputItemsParameters : Swift.Sendable {
    public var after: Swift.String?
    public var include: [SetappAI.SetappAIAPI.Responses.Include]?
    public var limit: Swift.Int?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(after: Swift.String? = nil, include: [SetappAI.SetappAIAPI.Responses.Include]? = nil, limit: Swift.Int? = nil)
    #endif
  }
}
extension SetappAI.SetappAIAPI.List where Element == SetappAI.SetappAIAPI.Responses.Input {
  @inlinable @inline(__always) public var inputItems: [SetappAI.SetappAIAPI.Responses.Input] {
    get {
        data ?? []
    }
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText {
  public struct Delta : Swift.Sendable {
    public var itemID: Swift.String {
      get
      set
    }
    public var outputIndex: Swift.Int?
    public var contentIndex: Swift.Int?
    public var delta: Swift.String
    public var sequenceNumber: Swift.Int?
    public var logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities]
    #if compiler(>=5.3) && $NonescapableTypes
    public init(itemID: Swift.String, outputIndex: Swift.Int?, contentIndex: Swift.Int?, delta: Swift.String, sequenceNumber: Swift.Int?, logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities])
    #endif
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Delta {
  public var type: SetappAI.SetappAIAPI.StreamingEvent.EventType {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Delta : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText {
  public struct Done : Swift.Sendable {
    public var itemID: Swift.String {
      get
      set
    }
    public var outputIndex: Swift.Int?
    public var contentIndex: Swift.Int?
    public var text: Swift.String
    public var sequenceNumber: Swift.Int?
    public var logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities]
    #if compiler(>=5.3) && $NonescapableTypes
    public init(itemID: Swift.String, outputIndex: Swift.Int?, contentIndex: Swift.Int?, text: Swift.String, sequenceNumber: Swift.Int?, logprobs: [SetappAI.SetappAIAPI.Responses.LogProbabilities])
    #endif
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Done {
  public var type: SetappAI.SetappAIAPI.StreamingEvent.EventType {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Done : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response {
  public enum OutputText : Swift.Sendable {
    case delta(SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Delta)
    case done(SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.Done)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText {
  public enum OutputTextType : Swift.String, Swift.Decodable, Swift.CaseIterable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case delta
    case done
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.OutputTextType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.OutputTextType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event {
  public enum EventType : Swift.String, Swift.Sendable, Swift.CaseIterable, Swift.Hashable, Swift.Equatable, Swift.RawRepresentable {
    case created
    case inProgress
    case completed
    case failed
    case incomplete
    case queued
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType : Swift.Decodable {
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle {
  public struct Event : Swift.Sendable {
    public var response: SetappAI.SetappAIAPI.Responses.Response
    public var sequenceNumber: Swift.Int
    public var type: SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType
    public init(response: SetappAI.SetappAIAPI.Responses.Response, sequenceNumber: Swift.Int, type: SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response {
  public enum ResponseLifecycle : Swift.Sendable {
    case created(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
    case inProgress(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
    case completed(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
    case failed(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
    case incomplete(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
    case queued(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response {
  public struct Error : Swift.Sendable {
    public var code: Swift.String?
    public var message: Swift.String?
    public var param: Swift.String?
    public var sequenceNumber: Swift.Int?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(code: Swift.String?, message: Swift.String?, param: Swift.String?, sequenceNumber: Swift.Int?)
    #endif
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.Error {
  public var type: SetappAI.SetappAIAPI.StreamingEvent.EventType {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.Error : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.Error : Swift.Error {
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.Error : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.Error : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response {
  public enum EventType : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public typealias RawValue = Swift.String
    case responseLifecycle(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle.Event.EventType)
    case outputText(SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.OutputTextType)
    case error
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: SetappAI.SetappAIAPI.StreamingEvent.Response.EventType.RawValue)
    #endif
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.EventType {
  @inlinable @inline(__always) public static var allCases: [SetappAI.SetappAIAPI.StreamingEvent.Response.EventType] {
    get {
        [error] + SetappAIAPI.StreamingEvent.Response.OutputText.OutputTextType.allCases.map(outputText) + SetappAIAPI
            .StreamingEvent.Response.ResponseLifecycle.Event.EventType.allCases.map(responseLifecycle)
    }
  }
  public var rawValue: SetappAI.SetappAIAPI.StreamingEvent.Response.EventType.RawValue {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.EventType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent {
  public enum Response : Swift.Sendable {
    case responseLifecycle(SetappAI.SetappAIAPI.StreamingEvent.Response.ResponseLifecycle)
    case outputText(SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText)
    case error(SetappAI.SetappAIAPI.StreamingEvent.Response.Error)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent.Response {
  public var type: SetappAI.SetappAIAPI.StreamingEvent.EventType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter {
  public enum Container : Swift.Sendable {
    case containerID(Swift.String)
    case auto(SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container.Auto)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container {
  public struct Auto : Swift.Sendable {
    public var type: Swift.String {
      get
    }
    public var fileIDs: [Swift.String]?
    public var memoryLimit: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit?
    public var networkPolicy: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fileIDs: [Swift.String]? = .none, memoryLimit: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit? = .none, networkPolicy: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container.Auto : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container.Auto : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter {
  public enum MemoryLimit : Swift.Sendable {
    public typealias RawValue = Swift.String
    case oneGigabyte
    case fourGigabytes
    case sixteenGigabytes
    case sixtyFourGigabytes
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter {
  public enum NetworkPolicy : Swift.Sendable {
    case disabled
    case allowlist(SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.Allowlist)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy {
  public struct Allowlist : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var allowedDomains: [Swift.String]
    public var domainSecrets: [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.Allowlist.DomainSecret]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(allowedDomains: [Swift.String], domainSecrets: [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.Allowlist.DomainSecret]? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.Allowlist {
  public struct DomainSecret : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var domain: Swift.String
    public var name: Swift.String
    public var value: Swift.String
    public init(domain: Swift.String, name: Swift.String, value: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy {
  public enum TypeValue : Swift.Sendable {
    public typealias RawValue = Swift.String
    case disabled
    case allowlist
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy.TypeValue.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter {
  public static func equal(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func notEqual(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func greaterThan(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func greaterThanOrEqual(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func lessThan(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func lessThanOrEqual(key: Swift.String, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func `in`(key: Swift.String, value: [Swift.String]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func `in`(key: Swift.String, value: [Swift.Double]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func notIn(key: Swift.String, value: [Swift.String]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func notIn(key: Swift.String, value: [Swift.Double]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func and(filters: [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
  public static func or(filters: [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter]) -> SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter {
  public struct Comparison : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var key: Swift.String
    public var type: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison.Operator
    public var value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value
    public init(key: Swift.String, type: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison.Operator, value: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison {
  public enum Operator : Swift.String, Swift.Sendable, Swift.Encodable, Swift.Decodable {
    case equal
    case notEqual
    case greaterThan
    case greaterThanOrEqual
    case lessThan
    case lessThanOrEqual
    case `in`
    case notIn
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter {
  public struct Compound : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var type: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound.Operator
    public var filters: [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter]
    public init(type: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound.Operator, filters: [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound {
  public enum Operator : Swift.String, Swift.Sendable, Swift.Encodable, Swift.Decodable {
    case and
    case or
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter {
  public enum Value : Swift.Sendable {
    case string(Swift.String)
    case number(Swift.Double)
    case boolean(Swift.Bool)
    case strings([Swift.String])
    case numbers([Swift.Double])
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Value : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch {
  public enum Filter : Swift.Sendable {
    case comparison(SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison)
    case compound(SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch {
  public struct RankingOptions : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var ranker: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker?
    public var scoreThreshold: Swift.Double?
    public var hybridSearch: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.HybridSearch?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(ranker: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker? = .none, scoreThreshold: Swift.Double? = .none, hybridSearch: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.HybridSearch? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions {
  public enum Ranker : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case default_2024_11_15
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions.Ranker.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions {
  public struct HybridSearch : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var embeddingWeight: Swift.Double?
    public var textWeight: Swift.Double?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(embeddingWeight: Swift.Double? = .none, textWeight: Swift.Double? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline {
  public struct Source : Swift.Sendable {
    public var data: Swift.String
    public var mediaType: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType
    public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType
    public init(data: Swift.String, mediaType: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType = .applicationZip, type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType = .base64)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source {
  public init(data: Foundation.Data, mediaType: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType = .applicationZip)
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source : Swift.Encodable, Swift.Decodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source {
  public enum MediaType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case applicationZip
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.MediaType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source {
  public enum SourceType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case base64
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source.SourceType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill {
  public struct Inline : Swift.Sendable {
    public var name: Swift.String
    public var source: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source
    public var description: Swift.String
    public init(name: Swift.String, source: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source, description: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill {
  public struct Reference : Swift.Sendable {
    public var skillID: Swift.String
    public var version: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(skillID: Swift.String, version: Swift.String? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Reference : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Reference : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Reference {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto {
  public enum Skill : Swift.Sendable {
    case skillReference(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Reference)
    case inline(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill {
  public enum SkillType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case skillReference
    case inline
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.SkillType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment {
  public struct ContainerAuto : Swift.Sendable {
    public var fileIDs: [Swift.String]?
    public var memoryLimit: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit?
    public var networkPolicy: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy?
    public var skills: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fileIDs: [Swift.String]? = .none, memoryLimit: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.MemoryLimit? = .none, networkPolicy: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.NetworkPolicy? = .none, skills: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill]? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment {
  public struct ContainerReference : Swift.Sendable {
    public var containerID: Swift.String
    public init(containerID: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerReference : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerReference : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerReference {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local {
  public struct Skill : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var name: Swift.String
    public var path: Swift.String
    public var description: Swift.String
    public init(name: Swift.String, path: Swift.String, description: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment {
  public struct Local : Swift.Sendable {
    public var skills: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local.Skill]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(skills: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local.Skill]? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell {
  public enum Environment : Swift.Sendable {
    case local(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local)
    case containerReference(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerReference)
    case containerAuto(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType>)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment {
  public enum EnvironmentType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case local
    case containerReference
    case containerAuto
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.EnvironmentType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Action : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case generate
    case edit
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Background : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case opaque
    case transparent
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum InputFidelity : Swift.Sendable {
    public typealias RawValue = Swift.String
    case low
    case high
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public struct InputImageMask : Swift.Sendable {
    public var fileID: Swift.String?
    public var imageURL: Swift.String?
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputImageMask {
  public init(fileID: Swift.String)
  public init(image: Foundation.Data, imageType: SetappAI.SetappAIAPI.Responses.Input.Message.Image.ImageType)
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputImageMask : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputImageMask : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Model : Swift.Sendable {
    public typealias RawValue = Swift.String
    case gptImage1
    case gptImage1Mini
    case gptImage15
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Moderation : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case low
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum OutputFormat : Swift.Sendable {
    public typealias RawValue = Swift.String
    case png
    case jpeg
    case webp
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Quality : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case low
    case medium
    case high
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration {
  public enum Size : Swift.Sendable {
    public typealias RawValue = Swift.String
    case auto
    case square1024
    case portrait1024x1536
    case landscape1536x1024
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP {
  public enum AllowedTools : Swift.Sendable {
    case toolNames([Swift.String])
    case filter(SetappAI.SetappAIAPI.Responses.Tool.MCP.ToolFilter)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.AllowedTools : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.AllowedTools : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP {
  public enum ConnectorID : Swift.Sendable {
    public typealias RawValue = Swift.String
    case dropbox
    case gmail
    case googleCalendar
    case googleDrive
    case microsoftTeams
    case outlookCalendar
    case outlookEmail
    case sharepoint
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP {
  public enum RequireApproval : Swift.Sendable {
    case policy(SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy)
    case filters(SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Filters)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval {
  public enum Policy : Swift.Sendable {
    public typealias RawValue = Swift.String
    case always
    case never
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval.Policy.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval {
  public struct Filters : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var always: SetappAI.SetappAIAPI.Responses.Tool.MCP.ToolFilter?
    public var never: SetappAI.SetappAIAPI.Responses.Tool.MCP.ToolFilter?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(always: SetappAI.SetappAIAPI.Responses.Tool.MCP.ToolFilter? = .none, never: SetappAI.SetappAIAPI.Responses.Tool.MCP.ToolFilter? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP {
  public struct ToolFilter : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var readOnly: Swift.Bool?
    public var toolNames: [Swift.String]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(readOnly: Swift.Bool? = .none, toolNames: [Swift.String]? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct ApplyPatch : Swift.Sendable {
    public init()
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ApplyPatch : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ApplyPatch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.ApplyPatch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public static var applyPatch: SetappAI.SetappAIAPI.Responses.Tool {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct CodeInterpreter : Swift.Sendable {
    public var container: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(container: SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter.Container? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct Computer : Swift.Sendable {
    public var environment: SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment
    public var displayWidth: Swift.Double
    public var displayHeight: Swift.Double
    public init(environment: SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment, displayWidth: Swift.Double, displayHeight: Swift.Double)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.Computer : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.Computer {
  public enum Environment : Swift.Sendable {
    public typealias RawValue = Swift.String
    case windows
    case mac
    case linux
    case ubuntu
    case browser
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.Computer.Environment.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.Computer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.Computer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct FileSearch : Swift.Sendable {
    public var vectorStoreIDs: [Swift.String]
    public var filters: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter?
    public var rankingOptions: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions?
    public var maxNumResults: Swift.Int?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(vectorStoreIDs: [Swift.String], filters: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter? = .none, rankingOptions: SetappAI.SetappAIAPI.Responses.Tool.FileSearch.RankingOptions? = .none, maxNumResults: Swift.Int? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct Function : Swift.Sendable {
    public var name: Swift.String
    public var parameters: [Swift.String : any Swift.Sendable]
    public var strict: Swift.Bool
    public var description: Swift.String?
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.Function : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.Function : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.Function : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct FunctionShell : Swift.Sendable {
    public var environment: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(environment: SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment? = .none)
    #endif
  }
  public typealias FunctionShellTool = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.FunctionShell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct ImageGeneration : Swift.Sendable {
    public var size: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size?
    public var quality: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality?
    public var outputFormat: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat?
    public var background: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background?
    public var action: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action?
    public var moderation: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation?
    public var outputCompression: Swift.Int?
    public var partialImages: Swift.Int?
    public var model: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model?
    public var inputFidelity: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity?
    public var inputImageMask: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputImageMask?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(size: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Size? = .none, quality: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Quality? = .none, outputFormat: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.OutputFormat? = .none, background: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Background? = .none, action: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Action? = .none, moderation: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Moderation? = .none, outputCompression: Swift.Int? = .none, partialImages: Swift.Int? = .none, model: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.Model? = .none, inputFidelity: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputFidelity? = .none, inputImageMask: SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration.InputImageMask? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct LocalShell : Swift.Sendable {
    public init()
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.LocalShell : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.LocalShell : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.LocalShell : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public static var localShell: SetappAI.SetappAIAPI.Responses.Tool {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct MCP : Swift.Sendable {
    public var serverLabel: Swift.String
    public var serverDescription: Swift.String?
    public var serverURL: Foundation.URL?
    public var connectorID: SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID?
    public var authorization: Swift.String?
    public var headers: [Swift.String : Swift.String]?
    public var allowedTools: SetappAI.SetappAIAPI.Responses.Tool.MCP.AllowedTools?
    public var requireApproval: SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval?
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(connectorID: SetappAI.SetappAIAPI.Responses.Tool.MCP.ConnectorID, serverLabel: Swift.String, serverDescription: Swift.String? = .none, authorization: Swift.String? = .none, headers: [Swift.String : Swift.String]? = .none, allowedTools: SetappAI.SetappAIAPI.Responses.Tool.MCP.AllowedTools? = .none, requireApproval: SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval? = .none)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(serverURL: Foundation.URL, serverLabel: Swift.String, serverDescription: Swift.String? = .none, authorization: Swift.String? = .none, headers: [Swift.String : Swift.String]? = .none, allowedTools: SetappAI.SetappAIAPI.Responses.Tool.MCP.AllowedTools? = .none, requireApproval: SetappAI.SetappAIAPI.Responses.Tool.MCP.RequireApproval? = .none)
  #endif
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.MCP : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool {
  public struct WebSearch : Swift.Sendable {
    public var webSearchType: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType
    public var filters: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.Filters?
    public var searchContextSize: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize?
    public var userLocation: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.ApproximateUserLocation?
    public var externalWebAccess: Swift.Bool?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(type: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType = .webSearch, filters: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.Filters? = .none, searchContextSize: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize? = .none, userLocation: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.ApproximateUserLocation? = .none, externalWebAccess: Swift.Bool? = .none)
    #endif
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch : SetappAI.SetappAIResponsesToolProtocol {
  public var type: SetappAI.SetappAIAPI.Responses.Tool.ToolType {
    get
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch {
  public struct Filters : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var allowedDomains: [Swift.String]
    public init(allowedDomains: [Swift.String])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch {
  public enum WebSearchType : Swift.Sendable {
    public typealias RawValue = Swift.String
    case webSearch
    case webSearch_2025_08_26
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.WebSearchType.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch {
  public enum SearchContextSize : Swift.Sendable {
    public typealias RawValue = Swift.String
    case low
    case medium
    case high
    case unsupported(SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize.RawValue)
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize : SetappAI.SetappAIRawStringRepresentableEnum {
  public static let allCases: [SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize]
  public var rawValue: SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize.RawValue {
    get
  }
  public typealias AllCases = [SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize]
  public typealias ExtendedGraphemeClusterLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize.RawValue
  public typealias StringLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize.RawValue
  public typealias UnicodeScalarLiteralType = SetappAI.SetappAIAPI.Responses.Tool.WebSearch.SearchContextSize.RawValue
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch {
  public struct ApproximateUserLocation : Swift.Sendable, Swift.Encodable, Swift.Decodable {
    public var country: Swift.String?
    public var region: Swift.String?
    public var city: Swift.String?
    public var timezone: Swift.String?
    public var type: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(country: Swift.String? = .none, region: Swift.String? = .none, city: Swift.String? = .none, timezone: Swift.String? = .none)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.Responses.Tool.WebSearch : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.Responses {
  public typealias ResponseError = SetappAI.SetappAIAPI.Responses.Error
  public typealias ResponseUsage = SetappAI.SetappAIAPI.Responses.Usage
  public typealias ResponseInputTokensDetails = SetappAI.SetappAIAPI.Responses.Usage.InputTokensDetails
  public typealias ResponseOutputTokensDetails = SetappAI.SetappAIAPI.Responses.Usage.OutputTokensDetails
  public typealias ResponseStatus = SetappAI.SetappAIAPI.Responses.Status
  public typealias ResponsePrompt = SetappAI.SetappAIAPI.Responses.Prompt
  public typealias ResponsePromptVariableValue = SetappAI.SetappAIAPI.Responses.Prompt.VariableValue
  public typealias ResponseIncompleteDetails = SetappAI.SetappAIAPI.Responses.IncompleteDetails
  public typealias ResponseDeleted = SetappAI.SetappAIAPI.Responses.DeletedResponse
  public typealias ResponseInstructions = SetappAI.SetappAIAPI.Responses.Instructions
  public typealias ResponseIncludable = SetappAI.SetappAIAPI.Responses.Include
  public typealias ResponseOutputMessage = SetappAI.SetappAIAPI.Responses.Output.Message
  public typealias ResponseOutputText = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text
  public typealias ResponseOutputRefusal = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Refusal
  public typealias ResponseOutputTextAnnotation = SetappAI.SetappAIAPI.Responses.Output.Message.Content.Text.Annotation
  public typealias ResponseFunctionToolCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function
  public typealias ResponseFileSearchToolCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch
  public typealias ResponseComputerToolCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer
  public typealias ResponseFunctionWebSearch = SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch
  public typealias ResponseCodeInterpreterToolCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter
  public typealias LocalShellCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell
  public typealias ShellCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Shell
  public typealias ApplyPatchCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch
  public typealias ResponseCustomToolCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Custom
  public typealias McpCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP
  public typealias ImageGenerationCall = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration
  public typealias FunctionCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Function
  public typealias LocalShellCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.LocalShell
  public typealias ShellCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Shell
  public typealias ApplyPatchCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch
  public typealias ResponseCustomToolCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Custom
  public typealias ComputerCallOutput = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer
  public typealias ResponseReasoningItem = SetappAI.SetappAIAPI.Responses.Output.ReasoningItem
  public typealias ResponseCompactionItemParam = SetappAI.SetappAIAPI.Responses.Output.CompactionItem
  public typealias McpListTools = SetappAI.SetappAIAPI.Responses.Output.MCPListTools
  public typealias McpApprovalRequest = SetappAI.SetappAIAPI.Responses.Output.MCPApprovalRequest
  public typealias ResponseInputItem = SetappAI.SetappAIAPI.Responses.Input
  public typealias EasyInputMessage = SetappAI.SetappAIAPI.Responses.Input.Message
  public typealias ResponseInputContent = SetappAI.SetappAIAPI.Responses.Input.Message.Content
  public typealias ResponseInputText = SetappAI.SetappAIAPI.Responses.Input.Message.Text
  public typealias ResponseInputImage = SetappAI.SetappAIAPI.Responses.Input.Message.Image
  public typealias ResponseInputFile = SetappAI.SetappAIAPI.Responses.Input.Message.File
  public typealias ItemReference = SetappAI.SetappAIAPI.Responses.Input.ItemReference
  public typealias McpApprovalResponse = SetappAI.SetappAIAPI.Responses.Input.MCPApprovalResponse
  public typealias FunctionTool = SetappAI.SetappAIAPI.Responses.Tool.Function
  public typealias FileSearchTool = SetappAI.SetappAIAPI.Responses.Tool.FileSearch
  public typealias ComputerTool = SetappAI.SetappAIAPI.Responses.Tool.Computer
  public typealias WebSearchTool = SetappAI.SetappAIAPI.Responses.Tool.WebSearch
  public typealias FunctionShellTool = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell
  public typealias ApplyPatchTool = SetappAI.SetappAIAPI.Responses.Tool.ApplyPatch
  public typealias CodeInterpreterTool = SetappAI.SetappAIAPI.Responses.Tool.CodeInterpreter
  public typealias LocalShellTool = SetappAI.SetappAIAPI.Responses.Tool.LocalShell
  public typealias ImageGenerationTool = SetappAI.SetappAIAPI.Responses.Tool.ImageGeneration
  public typealias LocalEnvironment = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local
  public typealias LocalSkill = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.Local.Skill
  public typealias ContainerReference = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerReference
  public typealias ContainerAuto = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto
  public typealias InlineSkill = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline
  public typealias InlineSkillSource = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Inline.Source
  public typealias SkillReference = SetappAI.SetappAIAPI.Responses.Tool.FunctionShell.Environment.ContainerAuto.Skill.Reference
  public typealias SummaryTextContent = SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.SummaryTextContent
  public typealias ReasoningTextContent = SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.ReasoningTextContent
  public typealias ResponseTextConfig = SetappAI.SetappAIAPI.Responses.Text
  public typealias ResponseLogProbabilities = SetappAI.SetappAIAPI.Responses.LogProbabilities
  public typealias ResponseLogProbability = SetappAI.SetappAIAPI.Responses.LogProbabilities.LogProbability
  public typealias ResponseRole = SetappAI.SetappAIAPI.Responses.Role
  public typealias ToolChoiceOptions = SetappAI.SetappAIAPI.Responses.ToolChoice.Options
  public typealias ToolChoiceAllowed = SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed
  public typealias ToolChoiceBuiltIn = SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn
  public typealias ToolChoiceFunction = SetappAI.SetappAIAPI.Responses.ToolChoice.Function
  public typealias ToolChoiceMcp = SetappAI.SetappAIAPI.Responses.ToolChoice.MCP
  public typealias ToolChoiceCustom = SetappAI.SetappAIAPI.Responses.ToolChoice.Custom
  public typealias ToolChoiceApplyPatch = SetappAI.SetappAIAPI.Responses.ToolChoice.ApplyPatch
  public typealias ToolChoiceShell = SetappAI.SetappAIAPI.Responses.ToolChoice.Shell
  public typealias ToolChoiceAllowedTool = SetappAI.SetappAIAPI.Responses.ToolChoice.Allowed.Tool
  public typealias ToolChoiceAllowedMode = SetappAI.SetappAIAPI.Responses.ToolChoice.AllowedMode
  public typealias ToolChoiceType = SetappAI.SetappAIAPI.Responses.ToolChoice.ToolChoiceType
  public typealias ToolChoiceBuiltInType = SetappAI.SetappAIAPI.Responses.ToolChoice.BuiltIn.BuiltInType
  public typealias ResponseFileSearchResult = SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Result
  public typealias ResponseApplyPatchOperation = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation
  public typealias ResponseApplyPatchCreateFile = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.CreateFile
  public typealias ResponseApplyPatchUpdateFile = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.UpdateFile
  public typealias ResponseApplyPatchDeleteFile = SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Operation.DeleteFile
  public typealias ResponseCodeInterpreterOutput = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output
  public typealias ResponseCodeInterpreterLogs = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Logs
  public typealias ResponseCodeInterpreterImage = SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Output.Image
  public typealias ResponseComputerSafetyCheck = SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.SafetyCheck
  public typealias ResponseComputerToolCallOutputScreenshot = SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Computer.Screenshot
  public typealias ResponseWebSearchActionSource = SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Action.Search.Source
  public typealias McpListToolsTool = SetappAI.SetappAIAPI.Responses.Output.MCPListTools.Tool
  public typealias ResponseContextManagement = SetappAI.SetappAIAPI.Responses.ContextManagement
  public typealias ResponseTruncation = SetappAI.SetappAIAPI.Responses.Truncation
  public typealias ResponseStreamOptions = SetappAI.SetappAIAPI.Responses.StreamOptions
  public typealias ResponseReasoningConfig = SetappAI.SetappAIAPI.Responses.Reasoning
}
extension SetappAI.SetappAIAPI {
  public struct List<Element> : Swift.Sendable where Element : Swift.Sendable {
    public var object: Swift.String {
      get
    }
    public var data: [Element]?
    public var firstID: Swift.String?
    public var lastID: Swift.String?
    public var hasMore: Swift.Bool
    #if compiler(>=5.3) && $NonescapableTypes
    public init(data: [Element]? = nil, firstID: Swift.String? = nil, lastID: Swift.String? = nil, hasMore: Swift.Bool)
    #endif
  }
}
extension SetappAI.SetappAIAPI.List : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.List : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SetappAI.SetappAIAPI.List : Swift.Equatable where Element : Swift.Equatable {
  public static func == (a: SetappAI.SetappAIAPI.List<Element>, b: SetappAI.SetappAIAPI.List<Element>) -> Swift.Bool
}
public enum SetappAIAPI {
}
public protocol SetappAIProtocol : Swift.Sendable {
  func set(configuration: SetappAI.AIConfiguration)
  var models: any SetappAI.SetappAIModelsAPIProtocol { get }
  var responses: any SetappAI.SetappAIResponsesAPIProtocol { get }
}
final public class CancellableAsyncStream<Element> : _Concurrency.AsyncSequence, Swift.Sendable where Element : Swift.Sendable {
  public typealias AsyncIterator = SetappAI.CancellableAsyncStream<Element>.Iterator
  public init(stream: _Concurrency.AsyncThrowingStream<Element, any Swift.Error>, onCancel: @escaping @Sendable () -> Swift.Void)
  @objc deinit
  final public func cancel()
  final public func makeAsyncIterator() -> SetappAI.CancellableAsyncStream<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes && $AsyncExecutionBehaviorAttributes
    @concurrent public mutating func next() async throws -> Element?
    #endif
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
}
extension SetappAI.SetappAIAPI.StreamingEvent {
  public enum EventType : Swift.Sendable, Swift.RawRepresentable, Swift.Hashable, Swift.Equatable {
    public typealias RawValue = Swift.String
    case response(SetappAI.SetappAIAPI.StreamingEvent.Response.EventType)
    case unsupported(SetappAI.SetappAIAPI.StreamingEvent.EventType.RawValue)
    public init(rawValue: Swift.String)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.EventType {
  public static var allCases: [SetappAI.SetappAIAPI.StreamingEvent.EventType] {
    get
  }
  public var rawValue: SetappAI.SetappAIAPI.StreamingEvent.EventType.RawValue {
    get
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent.EventType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI {
  public enum StreamingEvent : @unchecked Swift.Sendable {
    case response(SetappAI.SetappAIAPI.StreamingEvent.Response)
    case unsupported(SetappAI.SetappAIAPI.UnsupportedObject<SetappAI.SetappAIAPI.StreamingEvent.EventType>)
  }
}
extension SetappAI.SetappAIAPI.StreamingEvent : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SetappAI.SetappAIAPI.StreamingEvent {
  public var type: SetappAI.SetappAIAPI.StreamingEvent.EventType {
    get
  }
}
extension SetappAI.ErrorHandlingMode : Swift.Equatable {}
extension SetappAI.ErrorHandlingMode : Swift.Hashable {}
extension SetappAI.SetappAIError.ErrorCode : Swift.Hashable {}
extension SetappAI.SetappAIError.ErrorCode : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ReasoningItem.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ApplyPatch.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.CodeInterpreter.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Computer.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.FileSearch.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.LocalShell.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.Function.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.ImageGeneration.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.MCP.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolCall.WebSearch.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.ApplyPatch.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Output.ToolOutput.Status : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.StreamingEvent.Response.OutputText.OutputTextType : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison.Operator : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison.Operator : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Comparison.Operator : Swift.RawRepresentable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound.Operator : Swift.Equatable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound.Operator : Swift.Hashable {}
extension SetappAI.SetappAIAPI.Responses.Tool.FileSearch.Filter.Compound.Operator : Swift.RawRepresentable {}
